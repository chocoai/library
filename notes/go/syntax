1. 标识符引用：
当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），
这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。
2. 变量声明方式：
a. 基本格式：var identifier type
(1) var v_name v_type
    v_name = value
(2) var v_name = value
(3) v_name := value
e.g.
var a int = 10
var b = 10
c := 10

b. 衍生格式：
var v_name1, v_name2, v_name3 type
var v_name1, v_name2, v_name3 = v1, v2, v3
v_name1, v_name2, v_name3 = v1, v2, v3

c. 全局变量声明方式：
var (
    v_name1 type1
    v_name2 type2
)
d. 使用 := 赋值操作符，是使用变量的首选形式，但是只能使用到函数体内，而不可以用于全局变量的声明与赋值。
e. 如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误。
f. 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a。
g. 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃；_ 实际上是一个只写变量，你不能得到它的值。
   这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。
h. 打印变量类型 - Printf plust %T

3. 常量：布尔、数字以及字符串
a. 基本格式：const identifier [type] = value
e.g. 
const a string = "abc"
const a = "abc"

b. 衍生格式：
const c_name1, c_name2 = value1, value2

c. 枚举：
const (
    Unknown = 0
    Female = 1
    Male = 2
)

4. 数组类型
a. 在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。
所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。
因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。
b. 声明形式
var a [5]byte
var c [5]*int
var d [2][3]int

c. 初始化
1）先声明再初始化
a = {'1','2','3'}
d = {{1,2,3},{4,5,6}}
2）直接声明并初始化
a := [3]byte{'1', '2', '3'}
a := [...]byte{'1', '2', '3'}
d := [2][3]int{[3]int{1,2,3},[3]int{4,5,6}}
d := [2][3]int{{1,2,3},{4,5,6}}

e.g.
arr2 := [5]int{1, 2, 3, 4, 5}   //指定长度为5，并赋5个初始值
arr3 := [5]int{1, 2, 3}         //指定长度为5，对前3个元素进行赋值，其他元素为零值
arr4 := [5]int{4: 1}            //指定长度为5，对第5个元素赋值
arr5 := [...]int{1, 2, 3, 4, 5} //不指定长度，对数组赋以5个值
arr6 := [...]int{8: 1}          //不指定长度，对第9个元素（下标为8）赋值1
