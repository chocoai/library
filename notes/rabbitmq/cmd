The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. 
Actually, quite often the producer doesn't even know if a message will be delivered to any queue at all.

Instead, the producer can only send messages to an exchange. An exchange is a very simple thing. 
On one side it receives messages from producers and the other side it pushes them to queues. 
The exchange must know exactly what to do with a message it receives.

The exchange must know exactly what to do with a message it receives. 
Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. 
The rules for that are defined by the exchange type.

1. 启动
rabbitmq-server start
service rabbitmq-server start

2. 查看Connection, Queue, Channel, User
rabbitmqctl list_connections
rabbitmqctl list_queues
rabbitmqctl list_channels
rabbitmqctl list_users

3. 查看集群状态
rabbitmqctl cluster_status

4. 查看未被确认的消息
rabbitmqctl list_queues name messages_ready messages_unacknowledged

5. When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to.
Two things are required to make sure that messages aren't lost:

(1) Message durability - BOTH Producer and Consumer
q, err := ch.QueueDeclare(
  "hello",      // name
  true,         // durable
  false,        // delete when unused
  false,        // exclusive
  false,        // no-wait
  nil,          // arguments
)
failOnError(err, "Failed to declare a queue")

Note: This durable option change needs to be applied to both the producer and consumer code.
      At this point we're sure that the task_queue queue won't be lost even if RabbitMQ restarts.
(2) message persistence - Producer only
err = ch.Publish(
  "",           // exchange
  q.Name,       // routing key
  false,        // mandatory
  false,
  amqp.Publishing {
    DeliveryMode: amqp.Persistent,
    ContentType:  "text/plain",
    Body:         []byte(body),
})
Note: Marking messages as persistent doesn't fully guarantee that a message won't be lost.

6. Fair dispatch - Consumer only
err = ch.Qos(
  1,     // prefetch count
  0,     // prefetch size
  false, // global
)

7. Exchange Types
direct, topic, headers and fanout
<fanout>
err = ch.ExchangeDeclare(  // BOTH Producer and Consumer
  "logs",   // name
  "fanout", // type
  true,     // durable
  false,    // auto-deleted
  false,    // internal
  false,    // no-wait
  nil,      // arguments
)
failOnError(err, "Failed to declare an exchange")

body := bodyFrom(os.Args)
err = ch.Publish( // Producer only
  "logs", // exchange
  "",     // routing key
  false,  // mandatory
  false,  // immediate
  amqp.Publishing{
          ContentType: "text/plain",
          Body:        []byte(body),
  })

We want to hear about all log messages, not just a subset of them. We're also interested only in currently flowing messages not in the old ones. 
To solve that we need two things.

Firstly, whenever we connect to Rabbit we need a fresh, empty queue. To do this we could create a queue with a random name, or, even better - 
let the server choose a random queue name for us.

Secondly, once we disconnect the consumer the queue should be automatically deleted.

q, err := ch.QueueDeclare( // Consumer only
  "",    // name
  false, // durable
  false, // delete when usused
  true,  // exclusive
  false, // no-wait
  nil,   // arguments
)
When the method returns, the queue instance contains a random queue name generated by RabbitMQ. 
For example it may look like amq.gen-JzTY20BRgKO-HjmUJj0wLg.
When the connection that declared it closes, the queue will be deleted because it is declared as exclusive.

8. Bindings
rabbitmqctl list_bindings
err = ch.QueueBind( // Consumer only
  q.Name, // queue name
  "",     // routing key
  "logs", // exchange
  false,
  nil
)
